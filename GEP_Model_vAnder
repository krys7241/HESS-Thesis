
import pandas as pd
from GEP_Parameters import *
from pyomo.environ import *
from pyomo.opt import SolverFactory
from pyomo.util.infeasible import log_infeasible_constraints
import logging

df_load_power = pd.read_csv("GEP_consumption_aggregated.csv")
df_radiation = pd.read_csv("50.88_4.29_radiation.csv")
df_wind_speed = pd.read_csv("50.88_4.29_wind_speed_100m.csv")

df_gepmodel = pd.DataFrame()
df_gepmodel['Load (kW)'] = df_load_power['Consumer_0']
df_gepmodel['PV Power (kW)']  = df_radiation['Radiation (Wh/mÂ²)']*pv_eff*pv_area*pv_units/1000     
df_gepmodel['WT Power (kW)'] = (df_wind_speed['Wind speed (m/s)']**3)*wt_surface*wt_number*wt_rho_air*wt_efficiency/1000

print(df_gepmodel)

time_range = range(start_time, end_time, time_period)

model = ConcreteModel() 

load = df_gepmodel['Load (kW)'] * time_step
pv_energy = df_gepmodel['PV Power (kW)'] * time_step
wt_energy = df_gepmodel['WT Power (kW)'] * time_step

model.periods_set = RangeSet(start_time, end_time-1) # Optimization horizon based on time_period-hour-long acurate elyather forecast assumption
#model.scenario = RangeSet(1, scenarios)    

# VARIABLE DEFINITION
    
# Variables associated to the project

model.net_present_cost = Var(within=NonNegativeReals)
model.curtailment = Var(model.periods_set, within=NonNegativeReals)
    
# Variables associated to the battery bank
model.bat_size = Var(initialize=200, within=Integers)
model.bat_cost = Var(within=NonNegativeReals)
model.bat_charge = Var(model.periods_set, within=NonNegativeReals) 
model.bat_discharge = Var(model.periods_set, within=NonNegativeReals)
model.bat_a = Var (model.periods_set, within=Binary)
model.bat_b = Var (model.periods_set, within=Binary)
model.bat_SOE = Var(model.periods_set, within=NonNegativeReals) 
model.bat_SOE_i = Var(within=NonNegativeReals)

# Variables associated to the water electrolyzer
model.ely_size = Var(initialize=50, within=Integers)
model.ely_cost = Var(within=NonNegativeReals)
model.ely_elect = Var(model.periods_set, within=NonNegativeReals) 
model.ely_h2 = Var(model.periods_set, within=NonNegativeReals)
model.ely_power = Var(model.periods_set, within=NonNegativeReals) 
model.ely_a = Var (model.periods_set, within=Binary)
model.ely_b = Var (model.periods_set, within=Binary)
model.ely_c = Var (model.periods_set, within=Binary)
model.ely_a_i = Var (within=Binary)
model.ely_b_i = Var (within=Binary)
model.ely_c_i = Var (within=Binary)



# Variables associated to the fuel cell
model.fc_size = Var(initialize=50, within=Integers)
model.fc_cost = Var(within=NonNegativeReals)
model.fc_elect = Var(model.periods_set, within=NonNegativeReals) 
model.fc_h2 = Var(model.periods_set, within=NonNegativeReals) 
model.fc_power = Var(model.periods_set, within=NonNegativeReals)
model.fc_a = Var (model.periods_set, within=Binary)
model.fc_b = Var (model.periods_set, within=Binary)
model.fc_c = Var (model.periods_set, within=Binary)
model.fc_a_i = Var (within=Binary)
model.fc_b_i = Var (within=Binary)
model.fc_c_i = Var (within=Binary)

# Variables associated to the hydrogen tank
model.hs_size = Var(initialize=100, within=Integers)
model.hs_cost = Var(within=NonNegativeReals)
model.hs_SOE = Var(model.periods_set, within=NonNegativeReals)    
model.hs_SOE_i = Var(within=NonNegativeReals)

# EQUATIONS DEFINING OBJECTIVE FUNCTION AND CONSTRAINTS
    
# OBJECTIVE FUNCTION
model.Objective_Funtion = Objective(expr = model.net_present_cost, sense=minimize)  

def Net_Present_Cost(model):  
    return model.net_present_cost == model.bat_cost + model.ely_cost + model.fc_cost + model.hs_cost
model.c_Net_Present_Cost = Constraint(rule = Net_Present_Cost)


def BAT_Cost(model):
    return  model.bat_cost == model.bat_size * bat_capex 
model.c_bat_cost = Constraint(model.periods_set,  rule=BAT_Cost)
def ELY_Cost(model):
    return  model.ely_cost == model.ely_size * ely_capex
model.c_ely_cost = Constraint(model.periods_set,  rule=ELY_Cost)
def FC_Cost(model):
    return  model.fc_cost == model.fc_size * fc_capex
model.c_fc_cost = Constraint(model.periods_set,  rule=FC_Cost)
def HS_Cost(model):
    return  model.hs_cost == model.hs_size * hs_capex
model.c_hs_cost = Constraint(model.periods_set,  rule=HS_Cost)

# Energy Balancex
def Energy_Balance(model, i): # Energy balance
    return (
        load[i] - pv_energy[i] - wt_energy[i] + model.curtailment[i]
        - model.bat_b[i]*model.bat_discharge[i] + model.bat_a[i]*model.bat_charge[i] 
        + model.ely_elect[i] - model.fc_elect[i]  == 0
    )
model.c_Energy_Balance = Constraint(model.periods_set, rule=Energy_Balance)  # Energy balance
   
# Equations of the battery bank
def BAT_Charge_Limit_U(model, i): # 
    return model.bat_charge[i] <= model.bat_size*bat_C_charge
model.c_bat_power_charge_limup = Constraint(model.periods_set, rule=BAT_Charge_Limit_U)
def BAT_Charge_Limit_D(model, i): # 
    return 0 <= model.bat_charge[i]
model.c_bat_power_charge_limdown = Constraint(model.periods_set, rule=BAT_Charge_Limit_D)
def BAT_Discharge_Limit_U(model, i): # 
    return model.bat_discharge[i] <= model.bat_size*bat_C_discharge
model.c_bat_discharge_limup = Constraint(model.periods_set, rule=BAT_Discharge_Limit_U)
def BAT_Discharge_Limit_D(model, i): # 
    return 0 <= model.bat_discharge[i]
model.c_bat_discharge_limdown = Constraint(model.periods_set, rule=BAT_Discharge_Limit_D)
def BAT_State(model, i): 
    return model.bat_a[i] + model.bat_b[i] <= 1
model.c_bat_state = Constraint(model.periods_set, rule=BAT_State) # State of Charge of the batter
def BAT_SOE_Initial_State(model):
    return  model.bat_SOE_i == bat_SOE_i * model.bat_size  
model.c_bhs_SOE_initial_state = Constraint(rule=BAT_SOE_Initial_State) 
def BAT_SOE(model,i): # State of Charge of the battery
    if i == 0:
        return (
            model.bat_SOE[i] == model.bat_SOE_i 
            + model.bat_a[i]*bat_charge_eff*model.bat_charge[i]
            - model.bat_b[i]/bat_discharge_eff*model.bat_discharge[i]
        )
    else:  
        return (
            model.bat_SOE[i] == model.bat_SOE[i-1] 
            + model.bat_a[i]*bat_charge_eff*model.bat_charge[i] 
            - model.bat_b[i]/bat_discharge_eff*model.bat_discharge[i] 
        )
model.c_bat_SOE  = Constraint(model.periods_set, rule=BAT_SOE) # State of Charge of the battery
def BAT_SOE_Limit_U(model, i): # Maximun state of charge of the Battery
    return model.bat_SOE[i] <= model.bat_size
model.c_bat_SOE_limitup = Constraint(model.periods_set, rule=BAT_SOE_Limit_U) # Maximun state of 
def BAT_SOE_Limit_D(model, i): # Maximun state of charge of the Battery
    return bat_SOE_min * model.bat_size  <= model.bat_SOE[i]
model.c_bat_SOE_limitdown = Constraint(model.periods_set, rule=BAT_SOE_Limit_D) # Maximun state of 

# Equations for the water electrolyzer
def ELY_Elect (model,i ):
    return (
        model.ely_elect[i] == model.ely_power[i]*model.ely_a[i] 
        + ely_consumption_SB*model.ely_b[i] + ely_consumption_idle*model.ely_c[i]
    )
model.c_ely_elect = Constraint(model.periods_set, rule=ELY_Elect) 
def ELY_H2 (model,i ):
    if i == 0:
        return (
            model.ely_h2[i] == model.ely_size*model.ely_a[i]*ely_eff
            - model.ely_power[i]*ely_STT*model.ely_c_i*ely_eff
            )
    else:
        return (
            model.ely_h2[i] == model.ely_power[i]*model.ely_a[i]*ely_eff
            - model.ely_power[i]*ely_STT*model.ely_c[i-1]*ely_eff
            )
model.c_ely_h2 = Constraint(model.periods_set, rule=ELY_H2)
def ELY_State(model, i): 
    return model.ely_a[i] + model.ely_b[i] + model.ely_c[i]  <= 1 
model.c_ely_state = Constraint(model.periods_set, rule=ELY_State) 

def ELY_Power(model,i):
    return model.ely_power[i] <= model.ely_size
model.c_ely_power = Constraint(model.periods_set, rule=ELY_Power)

def ELY_MPL(model,i):
    return (ely_MPL*model.ely_a[i] <= model.ely_power[i])
model.c_ely_MPL = Constraint(model.periods_set, rule=ELY_MPL)

def ELY_a_Initial_State(model):
    return  model.ely_a_i == ely_b_i
model.c_ely_a_initial_state = Constraint(rule=ELY_a_Initial_State) 
def ELY_b_Initial_State(model):
    return  model.ely_b_i == ely_b_i       
model.c_ely_b_initial_state = Constraint(rule=ELY_b_Initial_State) 
def ELY_Idle_to_SB(model,i):
    if i == 0:
        return model.ely_b[i]+model.ely_c_i <= 1
    else:
        return  model.ely_b[i]+model.ely_c[i-1] <= 1
model.c_ely_idle_to_SB = Constraint(model.periods_set, rule=ELY_Idle_to_SB)
def ELY_SB_to_Idle(model,i):
    if i == 0:
        return model.ely_c[i] + model.ely_b_i <= 1
    else:
        return  model.ely_c[i] + model.ely_b[i-1] <= 1
model.c_ely_SB_to_idle = Constraint(model.periods_set, rule=ELY_SB_to_Idle)
    
# Equations for the fuel cell
def FC_Elect (model,i ):
    if i == 0:
        return (
            model.fc_elect[i] == model.fc_power[i]*model.fc_a[i] 
            - model.fc_power[i]*fc_STT*model.fc_c_i
            - model.fc_size*fc_consumption_SB*model.fc_b[i] - model.fc_size*fc_consumption_idle*model.fc_c[i]
        )
    else: 
        return (
            model.fc_elect[i] == model.fc_power[i]*model.fc_a[i] 
            - model.fc_power[i]*fc_STT*model.fc_c[i-1]
            - model.fc_size*fc_consumption_SB*model.fc_b[i] - model.fc_size*fc_consumption_idle*model.fc_c[i]
        )
model.c_fc_elect = Constraint(model.periods_set, rule=FC_Elect) 
def FC_H2 (model,i ):
    return model.fc_h2[i] == model.fc_power[i]*model.fc_a[i]/fc_eff
model.c_fc_h2 = Constraint(model.periods_set, rule=FC_H2)
def FC_State(model, i): 
    return model.fc_a[i] + model.fc_b[i] + model.fc_c[i] <= 1
model.c_fc_state = Constraint(model.periods_set, rule=FC_State) 
def FC_Power(model,i):
    return model.fc_power[i] <= model.fc_size
model.c_fc_power = Constraint(model.periods_set, rule=FC_Power)
def FC_MPL(model,i):
    return fc_MPL*model.fc_a[i] <= model.fc_power[i]
model.c_fc_MPL = Constraint(model.periods_set, rule=FC_MPL) 
def FC_a_Initial_State(model):
    return  model.fc_a_i == fc_a_i
model.c_fc_a_initial_state = Constraint(rule=FC_a_Initial_State) 
def FC_b_Initial_State(model):
    return  model.fc_b_i == fc_b_i 
model.c_fc_b_initial_state = Constraint(rule=FC_b_Initial_State)      
def FC_c_Initial_State(model):
    return  model.fc_c_i == fc_c_i
model.c_fc_c_initial_state = Constraint(rule=FC_c_Initial_State) 
def FC_Idle_to_SB(model,i):
    if i == 0:
        return model.fc_b[i] + model.fc_c_i <= 1
    else:
        return model.fc_b[i] + model.fc_c[i-1] <= 1
model.c_fc_idle_to_SB = Constraint(model.periods_set, rule=FC_Idle_to_SB)
def FC_SB_to_Idle(model,i):
    if i ==0 :
        return model.fc_c[i] + model.fc_b_i <= 1
    else:
        return model.fc_c[i] + model.fc_b[i-1]  <= 1
model.c_fc_SB_to_idle = Constraint(model.periods_set, rule=FC_SB_to_Idle)

# Equations for the hydrogen tank
def HS_SOE(model,i): # State of Charge of the battery
    if i == 0: 
        return model.hs_SOE[i] == model.hs_SOE_i + model.ely_h2[i] - model.fc_h2[i]
    else:  
        return model.hs_SOE[i] == model.hs_SOE[i-1] + model.ely_h2[i] - model.fc_h2[i]  
model.c_hs_SOE  = Constraint(model.periods_set, rule=HS_SOE) 

def HS_SOE_Limits_U(model, i): # Maximun state of charge of the Battery
    return model.hs_SOE[i] <= model.hs_size
model.c_hs_SOE_limitsup  = Constraint(model.periods_set, rule=HS_SOE_Limits_U)
def HS_SOE_Limits_D(model, i): # Maximun state of charge of the Battery
    return hs_SOE_min * model.hs_size <= model.hs_SOE[i]
model.c_hs_SOE_limitsdown  = Constraint(model.periods_set, rule=HS_SOE_Limits_D)
def HS_SOE_Initial_State(model):
    return  model.hs_SOE_i == hs_SOE_i
model.c_hs_SOE_initial_state = Constraint(rule=HS_SOE_Initial_State) 
def HS_State(model,i):
    return model.ely_a[i] + model.fc_a[i]  <= 1  
model.c_hs_State = Constraint(model.periods_set, rule=HS_State)    
    
# Solving the model with Gurobi
results = SolverFactory('gurobi')
    
# Setting up Gurobi
results.options["NonConvex"] = 2
results.options["Method"] = 0
results.options["Heuristics"] = 0.1
results.options["MIPfocus"] = 3
results.options["Presolve"] = 2
results.options["MIPGap"] = 0.05
results.solve(model, tee=True)
#results.solve(model, tee=True, options={'TimeLimit': 3000})
    
log_infeasible_constraints(model, log_expression=True, log_variables=True)
logging.basicConfig(filename='logging_info.log', encoding='utf-8', level=logging.INFO)
    
df_pyo_indexed = pd.DataFrame()  
df_pyo_scalar = pd.DataFrame()  
    
for v in model.component_objects(Var,active=True):
    if isinstance(v, pyomo.core.base.var.IndexedVar):
        df_pyo_indexed[str(v)] = [v[t]() for t in model.periods_set]
    elif isinstance(v, pyomo.core.base.var.ScalarVar):
        print(v)
        #print(v.value())    
    
# Printing the optimal results every 24h per time step - it overwrites the file
df_pyo_indexed.to_excel("Results_v2.xlsx") # Creating an excel file with the values of the variables that are in function of the periods
    